// Code generated by yarpc. DO NOT EDIT.

package contacts

import "context"
import "reflect"
import "github.com/libyarp/yarp"

func RegisterMessages() {
	yarp.RegisterStructType(Contact{}, Company{}, GetContactRequest{}, GetContactResponse{})
}

// Contact represent a single person in the address list.
type Contact struct {
	*yarp.Structure
	ID      *int64   `index:"0"`
	Name    string   `index:"1"`
	Surname string   `index:"2"`
	Company *Company `index:"3"`
	Emails  []string `index:"4"`
}

func (Contact) YarpID() uint64         { return 0x4325906dacf2f240 }
func (Contact) YarpPackage() string    { return "org.example.contacts" }
func (Contact) YarpStructName() string { return "Contact" }

// Company represents a company in which a person
// works at.
type Company struct {
	*yarp.Structure
	Name           string `index:"0"`
	WebsiteAddress string `index:"1"`
}

func (Company) YarpID() uint64         { return 0x6206673fbe9a2e7d }
func (Company) YarpPackage() string    { return "org.example.contacts" }
func (Company) YarpStructName() string { return "Company" }

// GetContactRequest represents a request to obtain
// a specific contact through a given id.
type GetContactRequest struct {
	*yarp.Structure
	ID int64 `index:"0"`
}

func (GetContactRequest) YarpID() uint64         { return 0x983aeeda1191e155 }
func (GetContactRequest) YarpPackage() string    { return "org.example.contacts" }
func (GetContactRequest) YarpStructName() string { return "GetContactRequest" }

// GetContactResposne represents the result of a GetContactRequest.
// An absent `contact` indicates that no contact under the provided id exists.
type GetContactResponse struct {
	*yarp.Structure
	Contact *Contact `index:"0"`
}

func (GetContactResponse) YarpID() uint64         { return 0x8002268d8858e505 }
func (GetContactResponse) YarpPackage() string    { return "org.example.contacts" }
func (GetContactResponse) YarpStructName() string { return "GetContactResponse" }

type ContactsServiceClient interface {
	// upsert_contact creates or updates a given contact.
	UpsertContact(ctx context.Context, req *Contact, optHeaders map[string]string) (yarp.Header, error)
	// list_contacts returns a stream of all known contacts.
	ListContacts(ctx context.Context, optHeaders map[string]string) (<-chan *Contact, yarp.Header, error)
	// get_contact obtains a single Contact by its ID.
	// Also see: GetContactRequest.
	GetContact(ctx context.Context, req *GetContactRequest, optHeaders map[string]string) (*GetContactResponse, yarp.Header, error)
}

type ContactsServiceServer interface {
	// upsert_contact creates or updates a given contact.
	UpsertContact(ctx context.Context, headers yarp.Header, req *Contact) (yarp.Header, error)
	// list_contacts returns a stream of all known contacts.
	ListContacts(ctx context.Context, headers yarp.Header, out *ContactStreamer) error
	// get_contact obtains a single Contact by its ID.
	// Also see: GetContactRequest.
	GetContact(ctx context.Context, headers yarp.Header, req *GetContactRequest) (yarp.Header, *GetContactResponse, error)
}

func NewContactsServiceClient(addr string, opts ...yarp.Option) ContactsServiceClient {
	return &_yarpClientContactsService{c: yarp.NewClient(addr, opts...)}
}

type _yarpClientContactsService struct {
	c *yarp.Client
}

func (cli *_yarpClientContactsService) UpsertContact(ctx context.Context, req *Contact, optHeaders map[string]string) (yarp.Header, error) {
	request := yarp.Request{
		Method:  0x92b3f6c7e01d8930,
		Headers: optHeaders,
	}

	_, headers, err := cli.c.DoRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	return headers, nil
}

func (cli *_yarpClientContactsService) ListContacts(ctx context.Context, optHeaders map[string]string) (<-chan *Contact, yarp.Header, error) {
	request := yarp.Request{
		Method:  0x2fb3a64267476ff6,
		Headers: optHeaders,
	}

	res, headers, err := cli.c.DoRequestStreamed(ctx, request, nil)
	if err != nil {
		return nil, nil, err
	}
	ch := make(chan *Contact, 10)
	go func() {
		defer close(ch)
		for i := range res {
			if v, ok := i.(*Contact); ok {
				ch <- v
			}
		}
	}()
	return ch, headers, nil
}

func (cli *_yarpClientContactsService) GetContact(ctx context.Context, req *GetContactRequest, optHeaders map[string]string) (*GetContactResponse, yarp.Header, error) {
	request := yarp.Request{
		Method:  0x18a3ffad2a8f68ce,
		Headers: optHeaders,
	}

	res, headers, err := cli.c.DoRequest(ctx, request, req)
	if err != nil {
		return nil, nil, err
	}
	if t, ok := res.(*GetContactResponse); ok {
		return t, headers, nil
	}
	return nil, nil, yarp.IncompatibleTypeError{
		Received: res,
		Wants:    reflect.TypeOf(&GetContactResponse{}),
	}
}

func RegisterContactsService(s *yarp.Server, v ContactsServiceServer) {
	s.RegisterHandler(0x92b3f6c7e01d8930, "org.example.contacts.ContactsService.upsert_contact", v.UpsertContact)
	s.RegisterHandler(0x2fb3a64267476ff6, "org.example.contacts.ContactsService.list_contacts", v.ListContacts)
	s.RegisterHandler(0x18a3ffad2a8f68ce, "org.example.contacts.ContactsService.get_contact", v.GetContact)
}

type ContactStreamer struct {
	h  yarp.Header
	ch chan<- *Contact
}

func (i ContactStreamer) Headers() yarp.Header { return i.h }
func (i ContactStreamer) Push(v *Contact)      { i.ch <- v }
