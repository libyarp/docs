# YARP's IDL

YARP is composed of three distinct components:

1. IDL files
2. Autogenerated Code
3. YARP's libraries

This document describes the first item, **IDL files**.
YARP's IDL files, or YARP's Interface Description Language is a small language
that allows developers to describe messages, fields, services, and methods.
Once a IDL file is created, it can be used to generate code responsible for
implementing Servers and Clients for a target programming language through
`yarpc` (YARP compiler).

Developers familiarised with Protocol Buffers and GRPC will find YARP's IDL
quite familiar. Through this document, we will define a Service called
`Contacts`, which will be responsible for keeping a very simple contact list.
The first statement (ignoring comments) on a YARP IDL file must identify which
package we are working on. This statement alone allows YARP to isolate services,
methods, and messages defined within the same package. For this example, we will
be building under the `org.example.contacts` package.

```diff
+ # contacts.yarp
+ package org.example.contacts;
```

From the small code snippet above, the following can be noticed:

1. Comments are indicated through the pound (`#`) symbol. Anything after a pound
up to the next line break is ignored by the compiler. (The first comment is not
required, it is there to indicate the name of the file we will be working on)
2. Statements ends with semi-colons (`;`).

Before continuing building the example, let's see which types are available for
developers to use.

## Primitive Types

YARP can encode the following types out-of-box:

### Scalar Values

| Type   | Size      | Description                |
|--------|-----------|----------------------------|
| uint8  | 1-2 bytes | 8-bit unsigned integer     |
| uint16 | 1-3 bytes | 16-bit unsigned integer    |
| uint32 | 1-6 bytes | 32-bit unsigned integer    |
| uint64 | 1-8 bytes | 64-bit unsigned integer    |
| int8   | 1-2 bytes | 8-bit signed integer       |
| int16  | 1-3 bytes | 16-bit signed integer      |
| int32  | 1-6 bytes | 32-bit signed integer      |
| int64  | 1-9 bytes | 64-bit signed integer      |
| bool   | 1 byte    | boolean value (true/false) |

### Floating-Point Values

| Type    | Size      | Description                |
|---------|-----------|----------------------------|
| float32 | 5 bytes   | 32-bit IEEE754 float value |
| float64 | 9 bytes   | 64-bit IEEE754 float value |

### Arrays

In YARP, any field can be set to carry a list of items by adding a `@repeated`
annotation to a field. For instance, to have a list of strings, a field would
be declared as:

```
@repeated emails string = 10;
```

### Optional fields

Similarly on how arrays are defined, optional fields can also be declared by
appending them with a `@optional` annotation.

> :warning: **Important!** Optional fields cannot be applied to Arrays.

### Maps

Maps, also known as associative arrays are defined by the type `map<T, U>`. In
a message, a map field would be declared as:

```
social_networks map<String, String> = 10;
```

> :warning: **Important!**: On a `map<T, U>`, `T` must represent a primitive
type such as any scalar value (except `boolean`), and `strings`. Other types are
prohibited from being used as `T` on maps. `U` have no limitation.

### oneof Values

Fields declared as `oneof` can contain only one possible value among a delimited
set. For instance, assume a given message, which is used as a Request for a
specific endpoint that accepts either an `user_id` or an `email`:

```
message SearchUserRequest {
    oneof {
        user_id uint64 = 0;
        email string = 1;
    } = 0;
}
```

The following rules applies:

1. `oneof` fields by themselves, have no name, but they receive an index.
2. Fields inside `oneof` also receive indexes, but this time, they begin at
zero, meaning they are relative.
3. Fields declared inside `oneof` fields must not repeat outside it. For instance,
the following declaration causes a compilation error:

```
message SearchUserRequest {
    oneof {
        user_id uint64 = 0;
        email string = 1;
    } = 0;
    email string = 2; # Parse Error: Duplicated field 'email'.
}
```

## User-Defined Types

User-defined types are types declared by developers in IDL files, or imported
from external files. So far the only UDT we came across was two examples
declaring `SearchUserRequest`.

Throughout this document, other types will be declared and used.

----

Continuing defining the `Contacts` service, let's declare messages will be working
with:

```diff
# contacts.yarp
package org.example.contacts;

+ # Contact represent a single person in the address list.
+ message Contact {
+     @optional id int64         = 0;
+     name string                = 1;
+     surname string             = 2;
+     @optional company Company  = 3;
+     @repeated emails string    = 4;
+ }
+
+ # Company represents a company in which a person
+ # works at.
+ message Company {
+     name string = 0;
+     website_address string = 1;
+ }
```

The example grew a bit. Let's see what's new:

1. A `Contact` message was declared, with the following fields:
1.1. An optional `id` field. This will allow us to upsert in case the message
arrives with an ID from the Client.
1.2. Required `name` and `surname` fields, both strings.
1.3. An optional `company` field that uses the `Company` UDT as its type.
1.4. A list of `emails`.
2. A `Company` message was declared, with the following fields:
2.1. A required `name`
2.2. A required `website_address`

The following style rules can also be noticed:

1. Messages uses `PascalCase` as their names. Always beginning with an uppercase
character.
2. Fields uses `snake_case`.
3. Blocks of comments directly attached to messages, services, fields, and
methods will be reused by the compiler to document generated files.


And the following IDL rules is also present:
1. Fields always begins at zero.
2. Declared fields are contiguous. This means that the field index cannot jump
from 1 to 3. Leaving gaps on message declarations will cause compilation errors,
and `yarpc` will refuse to generate sources for invalid messages.

So far we have messages declared, but no service. Next, let's augment the IDL
file with a service declaration.

```diff
# contacts.yarp
package org.example.contacts;

# Contact represent a single person in the address list.
message Contact {
    @optional id int64         = 0;
    name string                = 1;
    surname string             = 2;
    @optional company Company  = 3;
    @repeated emails string    = 4;
}

# Company represents a company in which a person
# works at.
message Company {
    name string = 0;
    website_address string = 1;
}

+ # GetContactRequest represents a request to obtain
+ # a specific contact through a given id.
+ message GetContactRequest {
+     id int64 = 0;
+ }
+
+ # GetContactResposne represents the result of a GetContactRequest.
+ # An absent `contact` indicates that no contact under the provided id exists.
+ message GetContactResponse {
+     @optional contact Contact = 0;
+ }
+
+ service ContactsService {
+     # upsert_contact creates or updates a given contact.
+     upsert_contact(Contact);
+
+     # list_contacts returns a stream of all known contacts.
+     list_contacts() -> stream Contact;
+
+     # get_contact obtains a single Contact by its ID.
+     # Also see: GetContactRequest.
+     get_contact(GetContactRequest) -> GetContactResponse;
+ }
```

Now, the file also contains a `GetContactRequest` and `GetContactResponse`.
Introducing Request/Response messages is always a good idea, since fields can
be added to messages without causing the protocol to break
backwards-compatibility, but changing a method's signature represents a major
break.

## Declaring Services
Services are declared through a `service` keyword, followed by the service name
in `PascalCase`.

Each service have a set of methods that:

1. Contains an optional argument type.
2. Contains an optional return type.
3. May indicate that the result is streamed.

The `ContactsService` service contains three methods that exemplify usage of
those characteristics:

- `upsert_contact` accepts a `Contact` parameter, but returns nothing.
- `list_contacts` does not accept parameters, but returns a `stream` of
`Contact`s. Streams indicates that the service will send an arbitrary number of
objects of the same type.
-  `get_contact` accepts a `GetContactRequest` parameter, and returns a
`GetContactResponse`.

As `messages`, the following style rules applies:

1. Service's names are provided in `PascalCase`.
2. Method's names are provided in `snake_case`.
3. Contiguous blocks of comments immediately before a service or method with
no blank lines between may be used by `yarpc` to provide documentation to
generated code.
