# Using `yarpc`

Once IDLs are in place, `yarpc` can be used to generate code implementing
definitions from those sources.

> ℹ️ **Notice**: This document uses files defined in [YARP's IDL](yarps-idl.md).

In order to generate code implementing definitions from `contacts.yarp` to Go
source files, the following arguments can be provided to `yarpc`:

```
$ yarpc go --out ./contacts.yarp.go ./contacts.yarp
Wrote: ./contacts.yarp.go
```

The command-line arguments are:

```
$ yarpc go --out ./contacts.yarp.go ./contacts.yarp
        ^^ ^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^
        |             |                    |
        |             |                    \_> IDL Source File
        |             \_> output file
        \_> Target Language
```

> **ProTip™**: Command line options may vary depending on the target language.
Use `yarpc <language> --help` to obtain a list of parameters available for your
target language.

Opening the generated `.go` file, we will encounter the following contents:

```go
// Code generated by yarpc. DO NOT EDIT.

package contacts

import "context"
import "reflect"
import "github.com/libyarp/yarp"

func RegisterMessages() {
    yarp.RegisterStructType(Contact{}, Company{}, GetContactRequest{}, GetContactResponse{})
}

// Contact represent a single person in the address list.
type Contact struct {
    *yarp.Structure
    ID      *int64   `index:"0"`
    Name    string   `index:"1"`
    Surname string   `index:"2"`
    Company *Company `index:"3"`
    Emails  []string `index:"4"`
}

func (Contact) YarpID() uint64         { return 0x4325906dacf2f240 }
func (Contact) YarpPackage() string    { return "org.example.contacts" }
func (Contact) YarpStructName() string { return "Contact" }

// Company represents a company in which a person
// works at.
type Company struct {
    *yarp.Structure
    Name           string `index:"0"`
    WebsiteAddress string `index:"1"`
}

func (Company) YarpID() uint64         { return 0x6206673fbe9a2e7d }
func (Company) YarpPackage() string    { return "org.example.contacts" }
func (Company) YarpStructName() string { return "Company" }

// GetContactRequest represents a request to obtain
// a specific contact through a given id.
type GetContactRequest struct {
    *yarp.Structure
    ID int64 `index:"0"`
}

func (GetContactRequest) YarpID() uint64         { return 0x983aeeda1191e155 }
func (GetContactRequest) YarpPackage() string    { return "org.example.contacts" }
func (GetContactRequest) YarpStructName() string { return "GetContactRequest" }

// GetContactResposne represents the result of a GetContactRequest.
// An absent `contact` indicates that no contact under the provided id exists.
type GetContactResponse struct {
    *yarp.Structure
    Contact *Contact `index:"0"`
}

func (GetContactResponse) YarpID() uint64         { return 0x8002268d8858e505 }
func (GetContactResponse) YarpPackage() string    { return "org.example.contacts" }
func (GetContactResponse) YarpStructName() string { return "GetContactResponse" }

type ContactsServiceClient interface {
    // upsert_contact creates or updates a given contact.
    UpsertContact(ctx context.Context, req *Contact, optHeaders map[string]string) (yarp.Header, error)
    // list_contacts returns a stream of all known contacts.
    ListContacts(ctx context.Context, optHeaders map[string]string) (<-chan *Contact, yarp.Header, error)
    // get_contact obtains a single Contact by its ID.
    // Also see: GetContactRequest.
    GetContact(ctx context.Context, req *GetContactRequest, optHeaders map[string]string) (*GetContactResponse, yarp.Header, error)
}

type ContactsServiceServer interface {
    // upsert_contact creates or updates a given contact.
    UpsertContact(ctx context.Context, headers yarp.Header, req *Contact) error
    // list_contacts returns a stream of all known contacts.
    ListContacts(ctx context.Context, headers yarp.Header, out *ContactStreamer) error
    // get_contact obtains a single Contact by its ID.
    // Also see: GetContactRequest.
    GetContact(ctx context.Context, headers yarp.Header, req *GetContactRequest) (yarp.Header, *GetContactResponse, error)
}

func NewContactsServiceClient(addr string, opts ...yarp.Option) ContactsServiceClient {
    return &_yarpClientContactsService{c: yarp.NewClient(addr, opts...)}
}

type _yarpClientContactsService struct {
    c *yarp.Client
}

func (cli *_yarpClientContactsService) UpsertContact(ctx context.Context, req *Contact, optHeaders map[string]string) (yarp.Header, error) {
    request := yarp.Request{
        Method:  0x92b3f6c7e01d8930,
        Headers: optHeaders,
    }

    _, headers, err := cli.c.DoRequest(ctx, request, req)
    if err != nil {
        return nil, err
    }
    return headers, nil
}

func (cli *_yarpClientContactsService) ListContacts(ctx context.Context, optHeaders map[string]string) (<-chan *Contact, yarp.Header, error) {
    request := yarp.Request{
        Method:  0x2fb3a64267476ff6,
        Headers: optHeaders,
    }

    res, headers, err := cli.c.DoRequestStreamed(ctx, request, nil)
    if err != nil {
        return nil, nil, err
    }
    ch := make(chan *Contact, 10)
    go func() {
        defer close(ch)
        for i := range res {
            if v, ok := i.(*Contact); ok {
                ch <- v
            }
        }
    }()
    return ch, headers, nil
}

func (cli *_yarpClientContactsService) GetContact(ctx context.Context, req *GetContactRequest, optHeaders map[string]string) (*GetContactResponse, yarp.Header, error) {
    request := yarp.Request{
        Method:  0x18a3ffad2a8f68ce,
        Headers: optHeaders,
    }

    res, headers, err := cli.c.DoRequest(ctx, request, req)
    if err != nil {
        return nil, nil, err
    }
    if t, ok := res.(*GetContactResponse); ok {
        return t, headers, nil
    }
    return nil, nil, yarp.IncompatibleTypeError{
        Received: res,
        Wants:    reflect.TypeOf(&GetContactResponse{}),
    }
}

func RegisterContactsService(s *yarp.Server, v ContactsServiceServer) {
    s.RegisterHandler(0x92b3f6c7e01d8930, "org.example.contacts.ContactsService.upsert_contact", v.UpsertContact)
    s.RegisterHandler(0x2fb3a64267476ff6, "org.example.contacts.ContactsService.list_contacts", v.ListContacts)
    s.RegisterHandler(0x18a3ffad2a8f68ce, "org.example.contacts.ContactsService.get_contact", v.GetContact)
}

type ContactStreamer struct {
    h  yarp.Header
    ch chan<- *Contact
}

func (i ContactStreamer) Headers() yarp.Header { return i.h }
func (i ContactStreamer) Push(v *Contact)      { i.ch <- v }
```

Along those lines, the following can be found:

- Definitions for all messages `Contact`, `Company`, `GetContactRequest`,
`GetContactResponse`
- Interfaces for `ContactsServiceClient` and `ContactsServiceServer`. The first
allows clients to be mocked, the later, for servers to be implemented (see
below)
- Unexported `_yarpClientContactsService`, responsible for implementing a TCP
client for `ContactsServiceClient`. The type is returned by
`NewContactsServiceClient`
- Methods `RegisterMessages` and `RegisterContactsService`, responsible for
registering all message types, and used by server implementors to have RPC
methods registered within a server.

### Implementing a Server

In order to implement a server, one must simply conform to the
`ContactsServiceServer` interface, and use `RegisterContacts` to register it
with a `yarp.Server` instance.

For instance, let's implement the server using in-memory storage and a Mutex:

```go
# contacts.server.go
package contacts

import (
    "context"
    "github.com/libyarp/yarp"
    "sync"
)

type Service struct {
    idCounter int64
    mu        sync.Mutex
    contacts  map[int64]Contact
}

func (s *Service) insert(c *Contact) {
    s.mu.Lock()
    defer s.mu.Unlock()
    id := s.idCounter + 1
    s.idCounter = id
    c.ID = &id
    s.contacts[id] = *c
}

func (s *Service) update(id int64, c *Contact) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.contacts[id] = *c
}

func (s *Service) UpsertContact(ctx context.Context, headers yarp.Header, req *Contact) (yarp.Header, error) {
    if req.ID != nil {
        s.update(*req.ID, req)
    } else {
        s.insert(req)
    }
    return nil, nil
}

func (s *Service) ListContacts(ctx context.Context, headers yarp.Header, out *ContactStreamer) error {
    for _, c := range s.contacts {
        out.Push(&c)
    }
    return nil
}

func (s *Service) GetContact(ctx context.Context, headers yarp.Header, req *GetContactRequest) (yarp.Header, *GetContactResponse, error) {
    v, ok := s.contacts[req.ID]
    if !ok {
        return nil, &GetContactResponse{}, nil
    }
    return nil, &GetContactResponse{Contact: &v}, nil
}

func RunServer() {
    RegisterMessages()
    s := yarp.NewServer("localhost:9027")
    service := &Service{
        idCounter: 0,
        mu:        sync.Mutex{},
        contacts:  map[int64]Contact{},
    }
    RegisterContactsService(s, service)
    s.Start()
}

```

The magic happens in `RunServer`:
1. `RegisterMessages` is invoked, registering all types with the in-memory
registry. This is essential to have it working correctly, since it indicates how
YARP should handle incoming types.
2. A new server is created listening on port 9027
3. The type implementing `ContactsServiceServer` is initialised.
4. The initialised type is registered against the server by invoking
`RegisterContactsService`. This step registers handlers for all RPC methods of
the `ContactsService`.
5. The server is then started. `Start` will block the calling goroutine until
`Shutdown` is invoked. This can be done like any other http server.

## Using a Client

Creating a client to consume a service requires even less code. For instance,
let's create a client and register a contact:

```go
# contacts.client.go
package contacts

import "context"

func RegisterContact() {
    c := NewContactsServiceClient("localhost:9027")
    contact := &Contact{
        ID:      nil,
        Name:    "Paul",
        Surname: "Appleseed",
        Company: nil,
        Emails:  []string{"paul.appleseed@icloud.com"},
    }
    _, err := c.UpsertContact(context.Background(), contact, nil)
    if err != nil {
        // ...
    }
}
```
